1. Создать новую ветку в гите - возможно это выльется в проект который мы сохраним как работу в твоё портфолио, поэтому я хочу отделить это.
2. Задание:
  Начнем с небольшого функционала и потом будет его расширять. Это важное условие, потому что тебе нужно постараться так формировать код, чтобы было легко добавлять новые фичи.
  Задание 09.10.2023
  Программа должна получать текущий курс биткоина и выводить его на экран.
  Задание 14.10.2023
  Среди всех токенов на бинансе найти топ3 с наибольшим приростом стоимости в процентах за прошедшую неделю и топ3 с наибольшим упадком. Вывести на экран
  Для топ1 в обоих номинациях посчитать стандартное отклонение на дневных свечах за месяц и сравнить с отклонением за прошедшую неделю из пункта 1. Вывести результаты на экран.
  Написать функцию custom_round, которая будет округлять до целого если стоимость актива >1000, до одного знака если между 100 и 1000, до двух знаков если между 1 и 100, и до 4 знаков если от 0 до 1. Все выводы на экран использовать только с этим округлением.
  Задание 01.10.2023
  1. Очень много разных функций со временем. Зачем они? В контексте данного задания тебе вообще нигде не нужно использовать время. У тебя есть интервалы - 1 день и два отрезка времени соотвественно - 7 дней и 30 дней. Зачем тебе вообще время? Я предоставил функцию чисто на тот случай если при распаковке джейсона ты захочешь посмотреть на поля и увидеть время в нормальном формате. Остальное всё не нужно - убираем.
  2. Программа работает очень долго - я так и не дождался вывода. Сделай атрибут запуска (в книге про это было, но если что почитай еще, можно использовать argparse, можно что-то, что найдешь). Сделай два - demo и work. При запуске demo (python main.py --demo) обрабатывались только первые 10 результатов из get_all_symbols_from_exchange_information. Соотвественно при запуске --work - все результаты без исключения.
  3. Решение с ендпоинтом который сразу показывает изменения в процентах в фукнции get_rolling_window_price_change_statistics мне понравилось, но что если потребуется считать разницу со стандартным отклонением не для топ1 результата а для всех? В таком случае количество обращений к апи (соотвественно стоимость и время работы программы) удвоится. Это нужно переделать. Гораздо проще сразу для всех токенов получить свечи (klines) на 30 дневном отрезки времени и сохранить это в лист в функции main. Тогда у всех функций ниже будет к нему доступ. После чего мы считаем разницу между открытием 7 дней назад и сегодняшним открытием (здесь нигде не нужно время, потому что свечи в джейсоне возвращаются уже в отсортированном по возрастанию порядке). После этого возвращаемся к сохраненному листу и считаем дивиацию для нужных токенов (а информация у нас уже есть, потому что изначально мы запросили свечи за 30 дней). Таким образом мы значительно сокращаем обращения к апи
  4. Чтобы пунк выше сработал, нужно перенести логику работы программы в main. Я уже об этом писал, но видимо мы друг друга не поняли. Я хочу видеть как работает программа в мейне. Соотвественно функции должны принимать локальные для main() атрибуты.
  5. Молодец что везде проверяешь, что ответ от апи будет с кодом 200. Но в текущей реализации это бесполезно. Подумай на шаг вперед - ну придет тебе ответ не 200, тебе запринтится ошибка и что дальше? А дальше программа продолжит работать, вернет пустой лист (например) и упадет на следующем шаге, попробовав обработать пустой лист.
Сократи обращения к апи до двух вызовов - первый это получение списка все токенов, второй - получение свеч для уже отфильтрованого списка. Реализуй вызов ексепшена и его обработку на случай любого ответа кроме 200.

  Задание 02.12.2023
  1. Сделать новый файл - outdated functionality (или любое название, которое будет отражать суть) - в этом файле будут храниться весь функционал который не входит
    в текущую реализацию, но уже был написан. Поместить в него всё что связано с STD - мне кажется ты так и не поняла в чем была задумка и тратить на это время больше нет смысла
  2. Переименовать main в procedure_main и оставить в нем только функционал выводящий топ прироста и топ падения
  3. Исправить вышеуказанный функционал - сейчас на небольшой демо выборке может возникнуть ситуация когда в плюсе меньше трех монеток, тогда топ прироста выведет отрицательные значения
    с точки зрения бизнеса это очень неправильно, поэтому выводить должно только(!) положительные значения в приросте и только отрицательные в упадке. Если таковых нет - выводить сообщение,
    что таких нет.
  4. на 46 строчке в мейне у тебя есть отсортированный список - всё что идет ниже (то что касается STD мы уже убрали) прячем в функцию принта, сразу после сортировки у тебя должен идти принт
  который принимает на вход этот отсортированный список и выводит красивенькое сообщение в консоль.

  На этом работа с файлом procedure_main будет окончена

  5. Читаем про ООП - читаем учебник главу 6 + читаем вот эту статью, мне кажется она даже лучше чем в учебнике - https://devpractice.ru/python-lesson-14-classes-and-objects/
  6. Реализуем этот же функционал с использованием принципов ООП. Создаем файл oop_main и новые вспомогательные файлы, чтобы новая реализация была отдельно от старых файлов, но в контексте одного проекта
  В данном случае классом у нас будет coin или token. Необходимый конструктор, поля и методы определи сама.
  В мейне должны быть только:
      1. Функционал argparse - попытайся максимально спрятать его реализацию, например передавай args.run как аргумент функции get_all_symbols_from_exchange_information()
      2. Получение списка токенов функцией get_all_symbols_from_exchange_information()
      3. Создание экземляров класса.
      4. Методы этого класса.
      5. Функции для реализации сортировки (для определения топ3 токенов).
  Принт должен быть реализован как метод класса (то есть после сортировки ты должна будешь для топ-3 токенов вызвать метод принт у соотвествующих экземляров классов)

  После выполнения этой части, убедись, что всё работает корректно, да в данной реализации у тебя будет больше обращений к апи, но на небольшой дистанции это не должно сыграть роли

  7. В базе создай простую таблицу со следующими атрибутами (атрибуты в контесте БД - столбцы):
  token_name, open_price_week_ago, open_price_today, price_diffrence, diffrence_type, load_timestamp
  типы полей определи сама
  8. Прочитай про psycopg2, если будут проблемы с установкой этого расширения напиши мне. Используй его чтобы заполнить вышесозданнную таблицу для отсортированных
  топ3 токенов. price_diffrence заполняй в процентах, diffrence_type - падение или прирост, load_timestamp - точное время загрузки
  Учитывая пункт 3 задания ответь для себя на вопрос - какое максимальное и минимальное количество записей может добавляться в твою таблицу за один запуск твоей программы.