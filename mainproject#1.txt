1. Создать новую ветку в гите - возможно это выльется в проект который мы сохраним как работу в твоё портфолио, поэтому я хочу отделить это. 
2. Задание: 
  Начнем с небольшого функционала и потом будет его расширять. Это важное условие, потому что тебе нужно постараться так формировать код, чтобы было легко добавлять новые фичи. 
  Задание 09.10.2023 
  Программа должна получать текущий курс биткоина и выводить его на экран.
  Задание 14.10.2023 
  Среди всех токенов на бинансе найти топ3 с наибольшим приростом стоимости в процентах за прошедшую неделю и топ3 с наибольшим упадком. Вывести на экран 
  Для топ1 в обоих номинациях посчитать стандартное отклонение на дневных свечах за месяц и сравнить с отклонением за прошедшую неделю из пункта 1. Вывести результаты на экран.
  Написать функцию custom_round, которая будет округлять до целого если стоимость актива >1000, до одного знака если между 100 и 1000, до двух знаков если между 1 и 100, и до 4 знаков если от 0 до 1. Все выводы на экран использовать только с этим округлением. 
  Задание 01.10.2023 
  1. Очень много разных функций со временем. Зачем они? В контексте данного задания тебе вообще нигде не нужно использовать время. У тебя есть интервалы - 1 день и два отрезка времени соотвественно - 7 дней и 30 дней. Зачем тебе вообще время? Я предоставил функцию чисто на тот случай если при распаковке джейсона ты захочешь посмотреть на поля и увидеть время в нормальном формате. Остальное всё не нужно - убираем. 
  2. Программа работает очень долго - я так и не дождался вывода. Сделай атрибут запуска (в книге про это было, но если что почитай еще, можно использовать argparse, можно что-то, что найдешь). Сделай два - demo и work. При запуске demo (python main.py --demo) обрабатывались только первые 10 результатов из get_all_symbols_from_exchange_information. Соотвественно при запуске --work - все результаты без исключения. 
  3. Решение с ендпоинтом который сразу показывает изменения в процентах в фукнции get_rolling_window_price_change_statistics мне понравилось, но что если потребуется считать разницу со стандартным отклонением не для топ1 результата а для всех? В таком случае количество обращений к апи (соотвественно стоимость и время работы программы) удвоится. Это нужно переделать. Гораздо проще сразу для всех токенов получить свечи (klines) на 30 дневном отрезки времени и сохранить это в лист в функции main. Тогда у всех функций ниже будет к нему доступ. После чего мы считаем разницу между открытием 7 дней назад и сегодняшним открытием (здесь нигде не нужно время, потому что свечи в джейсоне возвращаются уже в отсортированном по возрастанию порядке). После этого возвращаемся к сохраненному листу и считаем дивиацию для нужных токенов (а информация у нас уже есть, потому что изначально мы запросили свечи за 30 дней). Таким образом мы значительно сокращаем обращения к апи 
  4. Чтобы пунк выше сработал, нужно перенести логику работы программы в main. Я уже об этом писал, но видимо мы друг друга не поняли. Я хочу видеть как работает программа в мейне. Соотвественно функции должны принимать локальные для main() атрибуты. 
  5. Молодец что везде проверяешь, что ответ от апи будет с кодом 200. Но в текущей реализации это бесполезно. Подумай на шаг вперед - ну придет тебе ответ не 200, тебе запринтится ошибка и что дальше? А дальше программа продолжит работать, вернет пустой лист (например) и упадет на следующем шаге, попробовав обработать пустой лист. 
Сократи обращения к апи до двух вызовов - первый это получение списка все токенов, второй - получение свеч для уже отфильтрованого списка. Реализуй вызов ексепшена и его обработку на случай любого ответа кроме 200. 



